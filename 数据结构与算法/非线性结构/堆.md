# 堆

## 优先队列
### 定义
优先队列：一种特殊的队列，队列中元素出栈的顺序是按照元素的优先权大小，而不是元素的入队的先后顺序。

### 实现方式
1. 线性表
2. 堆(Heap)
3. 左高树

## 堆
### 堆的常用方法：
* 构建优先队列
* 支持堆排序
* 快速找出一个集合中的最（大、小）值

### 堆属性
堆分为两种：最大堆和最小堆，两者的差别在于结点的排序方式

在最大堆中，父结点的值比每一个自结点的值都要大。在最小堆中，父结点的值比每一个子结点的值都要小。这就是所谓的"堆属性"，并且这个属性对堆中的每一个结点都成立。

根据这一属性，那么最大堆总是将其中的最大值存放在树的根。而对于最小堆，根中的元素总是树中的最小值。堆属性非常有用，因为堆常常被当做优先队列使用，因为可以快速地访问到“最重要”的元素。

> 注意：堆的根中存放的是最大或者最小元素，但是其他的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。--唯一能够保证的是最小的元素是一个叶，但是不确定是哪一个。

### 堆和普通树的区别

堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：

* 结点的顺序：在二叉搜索树中，左子结点必须比父结点小，右子结点总比父结点大。但是在堆中并非如此。在最大堆中两个子都必须比父小，而在最小堆中，它们都必须比父大。

* 内存占用：占用的内存空间比它们存储的数据要多。你必须为对象以及左/右子指针分配内存。堆仅仅使用一个数据来存储数组，且不使用指针。

* 平衡：二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。

* 搜索：在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的放在最前面，从而快速的进行相关插入、删除操作。

### 计算

树的高度是指从树的根结点到最低的叶结点所需要的步数，或者更正式的定义：高度是指结点之间的边的最大值。一个高度为 h 的堆有 h+1 层。

[图-普通堆](https://upload-images.jianshu.io/upload_images/4064751-9a3b75e40d3f9f04.png?imageMogr2/auto-orient/strip|imageView2/2/w/471)

如果一个堆有 n 个结点，那么它的高度是 h = floor(log2(n))。这是因为我们总是要将这一层完全填满以后才会填充新的一层。上面的例子有 15 个结点，所以它的高度是 floor(log2(15)) = floor(3.91) = 3。

如果最下面的一层已经填满，那么那一层包含 2^h 个结点。树中这一层以上所有的结点数目为 2^h - 1。同样是上面这个例子，最下面的一层有8个结点，实际上就是 2^3 = 8。前面的三层一共包含7的结点，即：2^3 - 1 = 8 - 1 = 7。

所以整个堆中的结点数目为：* 2^(h+1) - 1*。上面的例子中，2^4 - 1 = 16 - 1 = 15

叶结点总是位于数组的 floor(n/2) 和 n-1 之间。


## 堆得抽象数据类型描述
类型名称：（最大）堆（MaxHeap，最大堆；MinHeap，最小队）
数据对象集合：完全二叉树，每个结点的元素值不小（大）于其子结点得元素

## 最大堆的操作
```C
typedef struct HeapStruct *MaxHeap;
struct HeapStruct {
    ElementType *Elements; /* 存储堆元素得数组 */
    int Size;   /* 堆当前的元素个数*/
    int Capacity; /* 堆的最大容量 */
}

MaxHeap Create(int MaxSize)
{
    MaxHeap H = malloc(sizeof(struct HeapStruct));
    H->ELements = malloc((MaxSize+1) * sizeof(ElementType));
    H->Size = 0;
    H->Capacity = MaxSize;
    H->ElementType[0] = MaxData; /* 定义哨兵为大于大堆中的所有可能元素的值，便于以后更快的操作。*/
    return H;
}
```

### 插入
```C
void Insert(MaxHeap H, ElementType item)
{
    /* 将元素item 插入最大堆H，其中H->Elements[0] 已经被定义为哨兵 */
    int i;
    if (IsFull(H)) {
        printf("最大堆已满")
        return
    }
    i = ++H->Size; /* i 指向插入后堆中的最后一个元素的位置 */
    for (; H->Elements[i/2] < item; i/=2)  
        H->Elements[i] = H->Elements[i/2];  /* 当前结点与父结点比较，插入结点比该父结点大，交换位置*/
        H->Elements[i] = item; /* 将item插入 */
}
```

### 删除
ElementType DeleteMax(MaxHeap H)
{
    int Parent, Child
    ElementType MaxItem, temp;
    if (IsEmpty(H)) {
        printf("最大堆已为空");
        return;
    }

    MaxItem = H->Elements[1]; /*取出根结点的最大值 */
    temp = H->Elements[H->Size--];
    for (Parent=1, Parent*2<= H->Size; Parent=Child) {
        Child = Parent * 2;
        if ( (Child!= H->Size) && (H->Elements[Child] < H->Elements[Child+1]) )
            Child++;    /* Child 指向左右子结点的较大者 */
        
        if ( temp >= H->Elements[Child]) break;

        /* 移动temp元素到下一层 */
        else 
            H->Elements[Parent] = H->Elements[Child];
    }

    H->Elements[Parent] = temp;
    return MaxItem;
    /* 用最大堆中最后一个元素从根结点开始向
}

### 建立
建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中

* 方法1：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为O(NlogN)。
* 方法2：在线性时间复杂度下建立最大堆。
    * 将N个元素按输入顺序存入，先满足二叉树的结构特性
    * 调整各结点的位置，以满足最大堆的有序特性