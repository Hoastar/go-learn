# B-tree
## 定义及性质
在b树中，分为两种结点：
* 内部结点（internal node）： 存输了数据以及指向其子结点的指针
* 叶子结点 （leaf node）：与内部结点不同的是，叶子结点值存储数据，并没有子结点

一个数据，既可能存在内部结点，也可能存在叶子结点上，其中与 B+树最大的不同，后者只会将数据存储在叶子结点上。

创建B树时，需要输入一个degree参数（以下简写为t），该参数决定了每个结点上数据量的多少，即结点的"胖"、"瘦"程度，而结点的胖瘦程度又会影响整棵树的高度，因为越胖的结点，树高度就越矮。

为了维持B树的平衡性，需要满足以下属性：

>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；

>（2）子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；

>（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);

>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;


* 在每个结点上的键值，以递增顺序排列，即 node.keys[i] <= node.keys[i+1]

* 在一个键值左边的子树，其键值大于该键值左边子树的所有键值，即 node.keys[i] > max(node.keys[i]的所有键值)；同时在一个键值右边的子树，其键值的最小值都不小于该键值，即 node.keys[i] <= min(node.child[i+1]的所有键值)。

* 在内部结点中，指向子结点的指针数量总数存储数据结点的数量+1，即：num(node.child) = num(node.keys) + 1
* 所有叶子结点的高度一致

* 无论是内部结点还是叶子结点，其存储的键数量在[m-1,2m-1]之间，如果数量不满足此条件，需要做重平衡操作。如果少于 m-1，需要借用或者合并数据；反之，如果数据量大于2m-1，则需要分裂成两个结点。

如下图所示，该图中的B树，m参数的值为2(注：一棵树中每个存储数据的地方，应该既有键(key) 也有数据(value)，然而本文为了简单起见，存储的数据只要键值。)

[图-b树示例](https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200609-btree-1/btree-example.png)

在上图中：
1. 由于 t=2，所有结点的键值数量在[1,3]之间
2. 所有的叶子结点的高度相同
3. 以左边的内部结点为例，其第一个键值为3，即该结点 keys[0]=3，而该键值的左子树的键(值)为[1,2]，都小于3，即 keys[0] > max(child[0]的所有键值)；而其右边子树的键值为[4,5,6]，都不小于3，即 keys[0] <= min(child[1]的所有键值)。


## 算法原理
接下来学习B树的两个核心操作：插入与删除。这两个操作的核心，都是在操作如果破坏了B树的平衡性之后，进行重新平衡以满足B树的性质。

### 插入数据

向B树中插入一个数据，可能会导致结点的数据变满，即不满足上面提到的结点数据数量在[t, 2t-1] 这个性质。此时需要对结点进行分裂结点操作：
* 将数据变满(即结点数据量为2t)的结点，分为左右两个数据量分别为 t-1 的结点，同时将中间的数据提升到父结点的合适位置上。
* 如果父结点由于新增了这个被提升的数据导致变满，就继续上面的分裂结点操作（递归）
* 沿着树向上一直执行该操作，直到不再变满为止。

分裂操作的示意图[图-B树分裂操作](https://cdn.jsdelivr.net/gh/lichuang/lichuang.github.io/media/imgs/20200609-btree-1/btree-split.png)

在上图中，由于插入数据，导致结点[P,Q,R,S,T,U,V] 数据量不满足平衡性要求，这是将其分裂成两个结点。同时将中间的结点S提升到父结点中形成[N,S,W]，同时修改子树指针。

### 删除数据
与插入操作相同，删除操作也可能会破坏B树的性质，需要进行重新平衡操作。
B树的删除算法，在沿着树向下查找待删除的结点的流程中，依次看到沿路的结点是否不满足至少有t个结点的条件，如果不满足这个条件就首先对这个结点进行平衡操作。由于在一开始就让沿路结点至少有t个结点，这样在删除数据后也至少能有 t-1 个数据满足平衡条件，这样就不用在删除之后还要回溯到祖先结点进行重平衡操作了。

> B树删除算法最核心：如果已知一个回溯操作不可避免，又无法预测到底在哪里发生，就在路上提前解决掉可能需要进行回溯操作的节点。

下面将在B树中删除一个数据分为以下几种情况进行讨论。

待整理：https://www.codedump.info/post/20200609-btree-1/

### 查询流程

利用一个图和一个实际的例子来理解B树（为了方便就直接使用实际字母的大小来排列 C>B>A

[图-B树](https://pic2.zhimg.com/80/v2-2c2264cc1c6c603dfeca4f84a2575901_720w.jpg)

B树的查询流程（示例：如上图找到字母E，流程如下）：

1. 获取根节点的关键字进行比较，当前根节点关键字为M，E<M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）
2. 拿到关键字D和G，D<E<G 所以直接找到D和G中间的节点；
3. 拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；