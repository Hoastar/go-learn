# 散列表

## 介绍

> 散列表（Hash table，也叫哈希表），是根据键（key）而直接访问在内存存储位置的数据结构。也就是说，它是通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问记录，这加快了查找速度。这个映射函数称作散列函数，存放记录的数组叫做散列表。

## 基本概念

* 若关键字为k，则其值存放在 F(k)的存储位置上。由此，无需比较便可直接取得所查记录，即称这个对应关系 F为散列函数，案该思想建立的表为散列表。

* 对不同的关键字可能得到同一散列地址，即 k1 <> k2，而 F(k1) = f(k2)，这种现象称为冲突（Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数 F(k)和 处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中"像"作为记录在表中的存储位置，这种表称为散列表，这一映射过程称为散列造表或者散列，所得的存储位置称散列地址

* 若对于关键字集合中的任一关键字，经散列函数映射到地址集合中的任何一个地址是的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就使关键字经过散列函数得到一个"随机的地址"，从而减少冲突。

## 散列函数

介绍散列函数前，我们先来介绍几个散列表的基本概念。在散列表内部，我们使用桶（bucket）来保存键值对，我们前面所说的数组索引即为桶号，决定了给定的键存于散列表的哪个桶中。散列表所拥有的桶数被称为散列表的容量（capacity）

现在假设我们的散列表中有M个桶，桶号为0到M-1。我们的散列函数的功能就是把任意给定的key转为[0, M-1]上的整数。我们对散列函数有两个基本要求：一是计算时间要短，二是尽可能把键分布在不同的桶中。对于不同类型的键，我们需要使用不同的散列函数，这样才能保证有比较好的散列效果。

* 散列函数，它对不同的输出值得到一个固定长度的消息摘要。理想的哈希函数对于不同的输入应该产生不同的结构，同时散列结果应当具有同一性（输出值尽量均匀）和雪崩效应（微小的输入值变化使得输出值发生巨大的变化）。

## 冲突解决

现实中的哈希函数不是完美的，当两个不同的输入值对应一个输出值时，就会产生“碰撞”，这个时候便需要解决冲突。

常见的冲突解决方法有开放定址法（线性探测、平方探测、伪随机探测），链地址法，建立公共溢出区，在散列，双散列等。实际的哈希表实现中，使用最多的是链地址法。


### 链地址法

前面我们谈到了散列冲突处理的开放定址法，它的思路就是一旦发生了冲突，就去寻找下一个空的散列地址。如果有冲突，能否在原地处理是否可行?

那么这样，就有了链地址法。

原理或者思路：将所有关键字为同义词的记录存储在一个单（向）链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。

示例：对于关键字集合{12,67,56,16,25,37,22,29,15,47,38,34}，我们用 集合元素数量，为除数，进行除留余数法：

[图-http://www.nowamagic.net/librarys/images/201303/2013_03_14_01.png] 

> 拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于 1，但一般均取α≤1。

链地址法的优势与缺点：

与开放定址法相比，拉链法有如下几个优点：
* 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；
* 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；
* 开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；
* 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元（即开放地址）都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

缺点：
指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。


## 查找效率

散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。

查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：

* 散列函数是否均匀
* 处理冲突的方法
* 散列表的荷载因子

### 查找效率

散列表的荷载因子定义为： α = 填入表中的元素个数/ 散列表的长度

α 是散列表装满程度的标志因子。由于表长是定值， α 与“填入表中的元素个数”成正比，所以， α 越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之， α 越小，标明填入表中的元素越少，产生冲突的可能性就越小。实际上，散列表的平均查找长度是载荷因子 α 的函数，只是不同处理冲突的方法有不同的函数。

对于开放定址法，荷载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。因此，一些采用开放定址法的hash库，如Java的系统库限制了荷载因子为0.75，超过此值将resize散列表。

## 局限性
> （1）Hash 索引适合定值查询，不能做范围查询
    由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和 Hash 运算前完全一样。
> （2）Hash 索引无法用于排序操作
    由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且 Hash 值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来进行任何排序运算；
> （3）Hash 索引不能利用部分索引键查询
    比如 (a,b,c) 形式的组合索引，查询中只用到了 a 和 b 也是可以查询的，如果使用 hash 表，组合索引会将几个字段合并 hash，没办法支持部分索引
> （4）Hash 索引遇到大量 Hash 值相等的情况后性能并不一定就会比 B-Tree 索引高
    数据库支持非唯一的 Hash 索引，如果遇到非唯一值，存储引擎会将他们链接到同一个 hash 键值下以一个链表的形式存在，然后在取得实际键值的时候再过滤不符合的键
