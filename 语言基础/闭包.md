# 闭包与匿名函数

## 匿名函数的定义与实现

顾名思义，函数没有名字，跟正常的函数调用区别不大。 Go 里面匿名函数与正常的函数区别，参数的传递区别不大，只是在调用方面，匿名函数需要通过一个包装对象`func1.f`` 来调用匿名函数，这个过程通过 rbx 进行二次寻址来完成调用。理论上，匿名函数也会比正常函数性能要差。

当我们不希望给函数起名字的时候，可以使用匿名函数，例如： 
```
func(x, y int) int { 
    return x + y 
}
```
可是这样一个函数不能够独立存在（编译器会返回错误：non-declaration statement outside function body），但可以被赋值于某个变量，即保存函数的地址到变量中：
```
fplus := func(x, y int) int { 
    return x + y
    }
```

然后通过变量名对函数进行调用：fplus(3, 4)。
当然也可以直接对匿名函数进行调用：
```
func(x, y int) int {
    return x + y
}(3,4)
```

以下示例计算整数1-10的总和的匿名函数：

```
func() {
    sum := 0
    for i := 1; i <= 10; i++ {
        sum += i
    }
}()
```
表示参数列表的第一对括号必须紧挨着关键字 func，因为匿名函数没有名称。花括号 {} 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。

## 闭包
### 闭包的定义

闭包是由函数及其相关的引用环境组合而成的实体（即：闭包=函数+引用环境）

### 引用环境的定义

> * 在函数式语言中，当内嵌函数体内引用到体外的变量时，将会把定义时涉及到的引用环境和函数体打包成一个整体（闭包）返回。现在给出引用环境的定义就很容易理解了：引用环境是指在程序执行中的某个点所有处于活跃状态的约束（一个变量的名字和其所代表的对象之间的联系）所组成的集合。闭包的使用和正常的函数调用没有区别。

> * 由于闭包把函数和运行时的引用环境打包成了一个整体，所以就解决了函数编程中的嵌套所引发的问题。当每次调用包含闭包的函数时都将返回一个新的闭包实例，这些实例直接是隔离的，分别包含调用时不同的引用环境现场。不同于函数，闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。

### 闭包的实现
闭包的实现也是一个匿名函数，一级指针在匿名函数里指向包装对象‘func1.f’，在闭包中，指向闭包返回对象。闭包返回的包装对象是一个复合结构体，里面包含匿名函数的地址，以及环境变量的地址。

#### 解析示例

##### 函数变量
在理解闭包之前，先学习一下什么是函数变量。
在go语言中，函数被看成是第一类值，这意味着函数像变量一样，有类型、有值、其他普通变量能做的事，它也可以。

```
func square(x int) {
    println(x * x)
}
```
使用方法：
1. 直接调用：square(1)
2. 把函数当成变量一样来赋值：s := square；接着可以调用这个函数变量：s(1)。注意这里赋值时 square 后面没有圆括号，调用才有。
    * 调用 nil 的函数变量会导致panic
    * 函数变量的零值是 nil，这意味着它可以跟 nil 比较，但这两个函数变量之间不能比较。


##### 闭包
```
func incr() func() int {    // "func() int" 为一个函数类型
    var x int
    return func() int {     // 函数字面量"func"
        x++ 
        return x
    }
}
``` 

调用该函数incr()会返回一个函数变量。

i := incr() ：通过把这个函数变量赋值给i，i 就成了一个闭包。
所以i保存着对 x 的引用。可以想象i中有着一个指针指向x或者i中有x的地址。
由于i有着指向x的指针，所以可以修改x，且保持着状态：
```
println(i())    // 1
println(i())    // 2
println(i())    // 3
```
也就是说，x逃逸了，它的生命周期没有随着它的作用域结束而接受。

但是如下代码却不会递增：
```
println(incr()())       // 1
println(incr()())       // 1
println(incr()())       // 1
```
这是因为这里调用了三次 incr()，返回了三个闭包，这三个闭包引用这不同的x，它们的状态是各自独立的

##### 闭包引用
现在开始通过例子来说明由闭包引用产生的问题：
```
x := 1
f := func() {
    println(x)
}
x = 2
x = 3
f()
```
因为闭包对外层词法域变量是引用的，所以会输出3。

可以想象f中保存这x的地址，它使用x时会直接解引用，所以x的值改变了会导致 f 解引用得到的值也会改变。

但是，这段代码却会输出 1：
```
x := 1
func() {
	println(x) // 1
}()
x = 2
x = 3
```

把它转换成这样的形式就容易理解了：
```
x := 1
f := func() {
	println(x)
}
f() // 1
x = 2
x = 3
```
这是因为 f 调用时就已经解引用取值了，这之后的修改就与它无关了。

不过如果再次调用 f 还是会输出 3，这也再一次证明了 f 中保存着 x 的地址。

可以通过在闭包内外打印所引用变量的地址来证明：
```
x := 1
func() {
	println(&x) 
}()
println(&x) 
```

##### 循环闭包引用
接下来在三个例子中说明循环内的闭包引用所产生的问题。
example 1

```
for i := 0; i < 3; i++ {
	func() {
		println(i) // 0, 1, 2
	}()
}
```
这段代码相当于：
```
for 1 := 0, i < 3; i++ {
    f := func() {
        println(i)
    }
    f()
}
```