# 哈希表
哈希表是除了数组之外，最常见的数据结构。几乎所有的语言都有数组和哈希表这两种集合元素，有的语言将数组实现成列表，有的语言将哈西表称作结构体或者字典，但是它们是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系，只是不同语言的叫法和实现稍微有些不同。

哈西表，可以根据键（key）直接访问内存中的存储位置，也就是说我们能够直接通过键找到键对应的一个值。

## 设计原理
哈希表是计算机科学中最重要的数据结构之一，这不仅仅因为它 O(1) 的读写性能比较优秀，还因为它提供了键值之间的映射。实现一个性能优异的哈希表，需要注意两个关键点 — 哈希函数和冲突解决方法。

### 哈希函数

实现哈希表的关键点在于如何选择哈希函数，哈希函数的选择在很大程度上能够决定哈希表的读写性能，在理想状态下，哈希函数应该能将不同键映射到不同的索引上，这要求哈希函数输出范围大于输入范围，但由于键的数量远远大于映射的范围，所以在实际使用时，这个理想的结构是不太可能实现的。

[图-完美哈希函数](https://img.draveness.me/2019-12-30-15777168478768-perfect-hash-function.png)]

比较实际的的方式是让哈希函数能够尽可能的均匀分布，然后通过工程手段解决哈希碰撞的问题，但是哈希的结果一定要尽可能的均匀分布，结果不均匀的哈希函数会造成更大的冲突并导致更差的读写性能。

[图-不均匀哈希函数](https://img.draveness.me/2019-12-30-15777168478768-perfect-hash-function.png)

在使用结果较为均匀的哈希函数中，哈希的增删改查都需要 O(1) 时间复杂度，但是非常不均匀的哈希函数会导致所有的操作都会占用最差 O(n) 的复杂读，所以在哈希表中使用好的哈希函数是至关重要的

### 冲突解决

就像我们先前所提到的，在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕是我们使用了完美的哈希函数，当输入的键足够多最终也能造成冲突。

然而我们的哈希表往往都是不完美的，输出的范围有限，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，最常见的就是开发寻址法和拉链法。

#### 开放寻址

开放寻址法是一种在哈希表中解决哈希碰撞的方法，这种方法的核心是对数组中的元素依次探测和笔记以判断目标键值对是否存在哈希表中，如果我们使用开放寻址法来实现哈希表，那么在支撑哈希表的数据结构就是数组，存储 (author, draven) 这个键值对从如下的所以开始遍历：

```
index := hash("author") % array.len
```

当我们向当前哈希表写入新数据时发生了冲突，就会将键值对写入到下一个不为空的位置：

[图-开放寻址法写入数据](https://img.draveness.me/2019-12-30-15777168478785-open-addressing-and-set.png)

如上图所示，当key3已经存入哈希表中的两个键值对 key1 和 key2 发生冲突时，key3 会被写入 key2 后面的空闲内存中；当我们再去读取 key3 对应的值时就会先对键进行哈希并取模，这会帮助我们先找到key1，因为key1与我们期望的键 Key3 不匹配，所以会继续查周后面的元素，直到内存为空或者找到目标元素。

[图-开放地址读取数据](https://img.draveness.me/2019-12-30-15777168478791-open-addressing-and-get.png)

当需要查找某个键对应的值时，就会从索引的位置开始对数组进行线性探测，找到目标键值对或者空内存就意味着这一次查询操作的结束。

开放寻址法中对性能影响最大的就是装载因子，它是数组中元素的数量与数组大小的比值，随着装载因子逐渐增大，线性探测的平均用时就会逐渐增加，着会同时影响哈希表的读写性能，当装载率超过70%之后，哈希表的性能就急剧下降，而一旦装载率达到100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 O(n)的，它们可能需要遍历数组中全部的元素，所以在实现哈希表时一定要时刻关注装载因子的变化。

#### 拉链法

与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语都会用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。

实现拉链法一般会使用数组加上链表，不过有一些语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以当成一个可以拓展的二维数组。

[图-拉链法写入数据](https://img.draveness.me/2019-12-30-15777168478798-separate-chaing-and-set.png)

如上图所示，当我们需要将一个键值对（key6, value6）写入哈希表时，键值对中的键 Key6 都先会经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，选择桶的方式就是直接对哈希返回的结果取模：

```
index := hash("Key6") % array.len
```

选择了2号桶后之后，就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：

1. 找到键相同的键值对 —— 更新键对应的值；
2. 没有找到键相同的键值对 —— 在链表的末尾追加新的键值对

将键值对写入哈希表之后，要通过某个键在其中获取映射的值，就会经历如下的过程：

[图-拉链法读取数据](https://img.draveness.me/2019-12-30-15777168478804-separate-chaing-and-get.png)

key11 展示了一个键在哈希表中不存在的例子，当哈希表发现它命中4号桶时，它会依次遍历桶中的链表，然而遍历到链表的末尾也没有到期望的键，所以哈希表中没有该键对应的值。

在一个性能比较好的哈希表里，每个桶至少都应该有0～1个元素，有时会有2~3个，很少会超过这个数量，计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：

```
装载因子 := 元素数量 / 桶数量
```

与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差，在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时就会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1/10，但是仍然比在链表中直接读写好 1000 倍。
